# Step 1


### 1. 작업 내용

- 단방향 연결리스트 구현 
    - 프로퍼티 `head`를 만들어서 리스트의 첫번째 노드를 가리키도록 해주었습니다.
    - `isEmpty`, `peek`은 리스트를 확인하는 용도로만 사용되어 연산 프로퍼티로 선언해주었고, `append`, `removeFirst`, `clear`는 실제 동작을 하기 때문에 메서드로 선언해주었습니다.
- 큐 구현
    - 단방향 연결리스트로 큐를 구현해주었습니다. 

### 2. 테스트 방법

- CommandLineTool 에서 Unit테스트를 추가해주는 방법은 달랐습니다! 

1. unitTest를 추가해준 뒤에 unit test를 할 각 파일에 Target Menbership 창에서 해당 Test에 체크를 해준다.

<img src="https://i.imgur.com/aaKWsyY.png" width="250" height="140"/>

2. Test Scheme 을 추가해준다 

<img src="https://i.imgur.com/XJrNhAS.png" width="300" height="350"/>

3. 유닛 테스트 프로덕트를 추가해준다.


<img src="https://i.imgur.com/4Qy6EyN.png" width="600" height="350"/>


### 3. UnitTest
- NodeTests
- LinkedListTests
- CustomerQueueTests

[참고 링크](https://jwonylee.tistory.com/entry/XCode-Swift-Command-Line-Tool-프로젝트에서-유닛-테스트-하기)

### 4. 스텝 핵심 경험

- [x] Linked-list 자료구조의 이해 및 구현
- [x] Queue 자료구조의 이해 및 구현
- [x] Generics 개념이해 및 적용

### 5. 고민한 점
<details>
<summary> 자세히 </summary>
<div markdown="1">
    
### 1. 연결리스트의 종류
- 이번 step2까지의 기능 명세서를 보았을 때는 리스트 중간에 데이터가 추가될 일이 없어보였고, 또 tail 변수를 만들어주어야 할 필요성을 느끼지 못해서 양방향 연결리스트가 아닌 단방향 연결리스트로 구현해주었습니다. 추후 확장성도 고려해봤을 때 양방향 연결리스트로 구현하는 것이 좋았을지 궁금합니다.

[라이언의 코멘트]

> 이런 경우 개발자들 사이에서도 의견이 나뉠 수 있는데, 개인적으로는 향후 반드시 사용되는 기능이 아니라면 구현하지 않는 방향이 좋다고 생각합니다. 좋게 표현하면 확장성, 나쁘게 표현하면 오버엔지니어링이니까요. 사용되지 않는 인터페이스를 유지할 필요는 없을 것이고, 필요하다면 해당 시기에 기능을 확장해나가면 되지 않을까요? 개발자는 불필요하다고 판단된다면 여러분처럼 과감하게 구현하지 않는 결단력도 있어야 한다고 생각합니다.

- 라이언의 코멘트에 따라 insert 작업이나 검색 작업이 필요할 경우 그때 연결리스트의 기능을 확장해주는 것을 선택하기로 했습니다. 따라서 이전과 같이 단방향 연결리스트로 구현해주었습니다.

### 2. Queue와 LinkedList의 차이점
- 큐와 연결리스트의 기능이 같아보이는데 따로 연결리스트와 큐 타입을 만들어서 큐에서 연결리스트의 기능을 가져와서 사용하는 것이 이해가 가지 않았습니다. 그냥 큐에서 바로 연결리스트의 기능을 구현해주면 되지 않나? 라고 생각했었습니다.
    -  찾아보니 큐는 구현 방법이 정의되어 있지 않은 자료형이고 연결리스트는 다음 데이터의 위치를 저장하는 방식인 자료구조기 때문에 따로 구현해줘야 함을 알게되었습니다! 저희가 생각한 것이 맞는지 궁금합니다.

[라이언의 코멘트]
> 물론 그렇게 구현해도 됩니다. 하지만 지금은 기능 명세에서 지정이 되어있으니 최대한 방향에 맞추어 구현해보는 것에 의의가 있다고 생각해요. 이렇게 구현했을 때의 장점은 여러분이 말씀하신 것처럼 큐를 구현하는 방법 (알고리즘)이 여러가지 존재하기 때문에 큐를 구성하는 알고리즘을 단위 테스트를 통해 검증할 수 있다는 것, 그리고 상황에 따라 더 높은 성능을 가지는 알고리즘으로 구현된 타입을 변경하며 사용할 수 있다는 장점이 있겠네요.

### 3. 구조체 내부에서 클래스 인스턴스를 생성하기
- CustomerQueue를 구조체로 만들어 주었는데, 안에 쓰이는 Node 인스턴스는 클래스(참조타입) 입니다. 이렇게 만들어줄 경우 CustomerQueue도 결국 참조타입이 되는 것인지 궁금합니다.

[라이언의 코멘트]
> 내부 프로퍼티 타입의 성질에 따라 그것을 가진 타입의 성질이 결정되지는 않습니다. 하지만 값 타입이 참조타입을 가질 경우 값 타입이 복사될 때마다 값 타입 내부의 참조 타입 인스턴스가 불필요하게 복사되는 경우가 발생할 수 있습니다.

[참고 링크](https://developer.apple.com/videos/play/wwdc2016/416/?time=893)
</div>
</details>


